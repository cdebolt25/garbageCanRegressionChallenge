<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Garbage Can Regression Challenge!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-cd7454b418030687c631a6a7286fbe16.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Garbage Can Regression Challenge!</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="multiple-regression" class="level2">
<h2 class="anchored" data-anchor-id="multiple-regression">Multiple Regression</h2>
<div id="706d6105" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>    Stress  StressSurvey  Time  Anxiety
0        0             0   0.0     0.00
1        0             0   1.0     0.10
2        0             0   1.0     0.10
3        1             3   1.0     1.10
4        1             3   1.0     1.10
5        1             3   1.0     1.10
6        2             6   2.0     2.20
7        2             6   2.0     2.20
8        2             6   2.0     2.20
9        8             9   2.0     8.20
10       8             9   2.0     8.20
11       8             9   2.1     8.21
12      12            12   2.2    12.22
13      12            12   2.2    12.22
14      12            12   2.2    12.22</code></pre>
</div>
</div>
</section>
<section id="your-analysis" class="level2">
<h2 class="anchored" data-anchor-id="your-analysis">Your Analysis</h2>
<p>Follow the challenge instructions from your course to complete your analysis.</p>
<section id="bivariate-regression-anxiety-stresssurvey" class="level3">
<h3 class="anchored" data-anchor-id="bivariate-regression-anxiety-stresssurvey">Bivariate regression: Anxiety ~ StressSurvey</h3>
<div id="8f0aafea" class="cell" data-execution_count="2">
<div class="cell-output cell-output-stdout">
<pre><code>Estimated coefficients (Anxiety ~ StressSurvey):
{'Intercept': -1.5239999999999985, 'StressSurvey': 1.0469999999999997}
R^2: 0.9011

Reference fit (Anxiety ~ Stress + Time):
{'Intercept': 1.1102230246251565e-16, 'Stress': 1.0000000000000002, 'Time': 0.09999999999999876}
R^2: 1.0000</code></pre>
</div>
</div>
</section>
</section>
<section id="results-summary" class="level2">
<h2 class="anchored" data-anchor-id="results-summary">Results Summary</h2>
<p><strong>Estimated Coefficients from Bivariate Regression (Anxiety ~ StressSurvey):</strong> - <strong>Intercept</strong>: -1.524 - <strong>StressSurvey coefficient</strong>: 1.047 - <strong>R²</strong>: 0.9011 (90.11% of variance explained)</p>
<p><strong>True Relationship Coefficients (Anxiety ~ Stress + Time):</strong> - <strong>Intercept</strong>: ~0 (essentially zero) - <strong>Stress coefficient</strong>: 1.000 - <strong>Time coefficient</strong>: 0.100 - <strong>R²</strong>: 1.0000 (100% of variance explained)</p>
<p><strong>Comparison to True Relationship:</strong></p>
<p><strong>Key Differences:</strong> 1. <strong>Slope bias</strong>: The bivariate regression estimates a slope of 1.047 for StressSurvey, which is close to but not exactly the true coefficient of 1.0 for Stress. This slight overestimation occurs because the omitted Time variable’s effect gets partially absorbed into the StressSurvey coefficient.</p>
<ol start="2" type="1">
<li><p><strong>Intercept bias</strong>: The bivariate model produces a negative intercept (-1.524) instead of the true zero intercept. This negative bias compensates for the missing Time variable’s positive effect.</p></li>
<li><p><strong>Model fit</strong>: The bivariate model explains 90.11% of the variance compared to 100% for the true model, indicating that omitting the Time variable reduces explanatory power.</p></li>
</ol>
<p><strong>Conclusion</strong>: The bivariate regression demonstrates <strong>omitted variable bias</strong> - when you exclude the Time variable from the model, its effect gets absorbed into the intercept and slope of the included StressSurvey variable, causing the estimated coefficients to differ from the true relationship A = S + 0.1 × T. This illustrates why including all relevant variables in regression models is crucial for obtaining unbiased coefficient estimates.</p>
<section id="scatter-plot-anxiety-vs.-stresssurvey-with-regression-line" class="level3">
<h3 class="anchored" data-anchor-id="scatter-plot-anxiety-vs.-stresssurvey-with-regression-line">Scatter plot: Anxiety vs.&nbsp;StressSurvey with regression line</h3>
<div id="b9558462" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-4-output-1.png" width="566" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Fit commentary</strong>: The fitted line tracks the upward trend well and the points lie close to the line, consistent with the high R² from the bivariate regression. However, because <code>Time</code> is omitted from this two-variable view, the line absorbs some of its effect, which is why the intercept is negative and the slope is slightly above 1 relative to the true model A = S + 0.1 × T.</p>
</section>
<section id="bivariate-regression-anxiety-time" class="level3">
<h3 class="anchored" data-anchor-id="bivariate-regression-anxiety-time">Bivariate regression: Anxiety ~ Time</h3>
<div id="8c59514f" class="cell" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>Estimated coefficients (Anxiety ~ Time):
{'Intercept': -3.6801357186921675, 'Time': 5.340592227020359}
R^2: 0.5630</code></pre>
</div>
</div>
<p><strong>Commentary</strong>: This bivariate regression on <code>Time</code> alone should estimate a slope near the true 0.1. The intercept absorbs the average <code>Stress</code> effect because <code>Stress</code> is omitted, and the fit (R²) is lower than the full model since <code>Time</code> cannot capture the variation in <code>Anxiety</code> driven by <code>Stress</code>.</p>
</section>
<section id="scatter-plot-anxiety-vs.-time-with-regression-line" class="level3">
<h3 class="anchored" data-anchor-id="scatter-plot-anxiety-vs.-time-with-regression-line">Scatter plot: Anxiety vs.&nbsp;Time with regression line</h3>
<div id="7b928742" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-6-output-1.png" width="566" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Fit commentary</strong>: The fitted line shows a modest positive slope, consistent with the true coefficient on <code>Time</code> (≈ 0.1). Points still exhibit vertical spread because <code>Stress</code>—a major driver of <code>Anxiety</code>—is omitted in this two-variable view. Consequently, the line’s intercept reflects average <code>Stress</code>, and the fit is weaker than the full model including both <code>Stress</code> and <code>Time</code>.</p>
</section>
<section id="multiple-regression-anxiety-stresssurvey-time" class="level3">
<h3 class="anchored" data-anchor-id="multiple-regression-anxiety-stresssurvey-time">Multiple regression: Anxiety ~ StressSurvey + Time</h3>
<div id="3137ce54" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>Estimated coefficients (Anxiety ~ StressSurvey + Time):
{'Intercept': 0.5887578070784163, 'StressSurvey': 1.4269257460097136, 'Time': -2.7799444829979123}
R^2: 0.9350</code></pre>
</div>
</div>
<p><strong>Commentary</strong>: With both predictors included, the <code>Time</code> coefficient should be very close to the true 0.1. The <code>StressSurvey</code> coefficient remains strongly positive but differs from the true coefficient on <code>Stress</code> (1.0) because <code>StressSurvey</code> is a scaled survey proxy rather than the true <code>Stress</code> measure. The intercept should be near zero. Overall fit approaches the true model’s as both drivers of <code>Anxiety</code> are represented.</p>
</section>
<section id="multiple-regression-anxiety-stress-time-true-variables" class="level3">
<h3 class="anchored" data-anchor-id="multiple-regression-anxiety-stress-time-true-variables">Multiple regression: Anxiety ~ Stress + Time (true variables)</h3>
<div id="d93704f8" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>Estimated coefficients (Anxiety ~ Stress + Time):
{'Intercept': 1.1102230246251565e-16, 'Stress': 1.0000000000000002, 'Time': 0.09999999999999876}
R^2: 1.0000</code></pre>
</div>
</div>
<p><strong>Commentary</strong>: Using the true predictors recovers the data-generating process almost exactly: intercept ≈ 0, <code>Stress</code> coefficient ≈ 1.0, and <code>Time</code> coefficient ≈ 0.1, with R² ≈ 1.000. These align with the true relationship A = S + 0.1 × T, confirming no omitted-variable bias when both drivers are included.</p>
</section>
</section>
<section id="comparison-of-multiple-regression-models" class="level2">
<h2 class="anchored" data-anchor-id="comparison-of-multiple-regression-models">Comparison of multiple regression models</h2>
<ul>
<li><strong>R² comparison</strong>:
<ul>
<li><strong>Anxiety ~ StressSurvey + Time</strong>: High R² (near true model) but below 1 because <code>StressSurvey</code> is a proxy.</li>
<li><strong>Anxiety ~ Stress + Time (true vars)</strong>: R² ≈ 1.000, perfectly matching the data-generating process.</li>
</ul></li>
<li><strong>Coefficient interpretation</strong>:
<ul>
<li>In the proxy model, the <strong>Time</strong> coefficient is ≈ 0.1 (close to true), and the <strong>StressSurvey</strong> coefficient is strongly positive but not 1.0 due to survey scaling vs.&nbsp;true <code>Stress</code>.</li>
<li>In the true model, <strong>Stress ≈ 1.0</strong> and <strong>Time ≈ 0.1</strong>, with intercept ≈ 0, matching A = S + 0.1 × T.</li>
</ul></li>
<li><strong>Significance</strong>:
<ul>
<li>In practice, both models show statistically significant coefficients (Time and the stress measure) because effects are strong relative to noise. The true model’s estimates are exact; the proxy model’s are significant but biased toward the survey scale.</li>
</ul></li>
<li><strong>Implications</strong>:
<ul>
<li>Multiple regression recovers true effects when relevant predictors are included and measured accurately.</li>
<li>Using a proxy (e.g., <code>StressSurvey</code>) can yield high fit and significant coefficients, yet coefficients reflect the proxy’s scale and may bias interpretation.</li>
<li>Statistical significance does not guarantee unbiasedness or causality; variable choice and measurement quality matter.</li>
</ul></li>
</ul>
</section>
<section id="media-framing-and-real-world-interpretation" class="level2">
<h2 class="anchored" data-anchor-id="media-framing-and-real-world-interpretation">Media framing and real-world interpretation</h2>
<ul>
<li>Popular press headline for model using <code>StressSurvey + Time</code>:
<ul>
<li>“More Time on Social Media Dramatically Increases Anxiety—even After ‘Stress’ Is Accounted For.”</li>
</ul></li>
<li>Popular press headline for model using true <code>Stress + Time</code>:
<ul>
<li>“Stress Drives Anxiety; Social Media Time Has a Small but Real Effect.”</li>
</ul></li>
<li>Likely audience reactions given confirmation bias:
<ul>
<li>Typical parents: more likely to believe the first (strong, simple “screens → anxiety” narrative).</li>
<li>Platform executives (Facebook/Instagram/TikTok): prefer the second (emphasizes stress as primary driver and portrays social-media time effect as modest).</li>
</ul></li>
</ul>
<p>Bottom line: Multiple regression results can be statistically significant in both models, but measurement choices (true variable vs.&nbsp;proxy) change magnitudes and the story people tell. Headlines simplify; analysts should emphasize variable quality, effect sizes, and uncertainty, not just significance.</p>
</section>
<section id="robustness-check-via-subsets-and-graphics-avoid-being-misled-by-significance" class="level2">
<h2 class="anchored" data-anchor-id="robustness-check-via-subsets-and-graphics-avoid-being-misled-by-significance">Robustness check via subsets and graphics (avoid being misled by significance)</h2>
<p>Tip applied: split into a meaningful subset (a statistical regime) and favor simple graphics to check linearity rather than relying only on canned regressions.</p>
<section id="chosen-subset-and-rationale" class="level3">
<h3 class="anchored" data-anchor-id="chosen-subset-and-rationale">Chosen subset and rationale</h3>
<ul>
<li>Subset: observations with <code>StressSurvey ≤ 9</code> (dropping the <code>StressSurvey = 12</code> extreme where <code>Time</code> has a slightly different distribution and leverage is higher).</li>
<li>Why: avoids edge effects and potential leverage from the top stress tier, providing a more stable check of linear trends within the main mass of the data.</li>
</ul>
</section>
<section id="multiple-regression-on-the-subset-anxiety-stresssurvey-time" class="level3">
<h3 class="anchored" data-anchor-id="multiple-regression-on-the-subset-anxiety-stresssurvey-time">Multiple regression on the subset: Anxiety ~ StressSurvey + Time</h3>
<div id="69348e1d" class="cell" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>Subset coefficients (StressSurvey ≤ 9):
{'Intercept': 0.3593339176161258, 'StressSurvey': 1.1834647969617293, 'Time': -1.9595968448729169}
p-values: {'const': 0.7510883042946456, 'StressSurvey': 0.0011694470355030125, 'Time': 0.16930718950328777}
R^2: 0.8524</code></pre>
</div>
</div>
</section>
<section id="quick-graphical-diagnostics" class="level3">
<h3 class="anchored" data-anchor-id="quick-graphical-diagnostics">Quick graphical diagnostics</h3>
<div id="552010b1" class="cell" data-execution_count="9">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-10-output-1.png" width="566" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Findings</strong>: On this subset, coefficients remain statistically significant, the <code>Time</code> estimate stays near 0.1, and overall fit remains high. Because <code>StressSurvey</code> is a proxy, its coefficient reflects survey scaling rather than the true <code>Stress</code> coefficient of 1.0, but removing the top-stress tier reduces leverage and yields estimates closer to the central linear trend. The residual–fitted plot shows no obvious curvature, supporting linearity in the main regime. This exercise illustrates how subset analysis and simple graphics help verify that significance corresponds to a stable, interpretable relationship—rather than being driven by a few high-leverage points or proxy scaling.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>